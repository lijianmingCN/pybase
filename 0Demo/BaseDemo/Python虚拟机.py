#!--coding:utf8--
#当虚拟机开始运⾏行时，它通过初始化函数完成整个运⾏行环境设置：
#• 创建解释器和主线程状态对象，这是整个进程的根对象。
#• 初始化内置类型。数字、列表等类型都有专⻔门的缓存策略需要处理。
#• 创建 __builtin__ 模块，该模块持有所有内置类型和函数。
#• 创建 sys 模块，其中包含了 sys.path、modules 等重要的运⾏行期信息。
#• 初始化 import 机制。
#• 初始化内置 Exception。
#• 创建 __main__ 模块，准备运⾏行所需的名字空间。
#• 通过 site.py 将 site-packages 中的第三⽅方扩展库添加到搜索路径列表。
#• 执行入口 py ⽂文件。执⾏行前会将 __main__.__dict__ 作为名字空间传递进去。
#• 程序执行结束。
#• 执行清理操作，包括调⽤用退出函数，GC 清理现场，释放所有模块等。
#• 终止进程。
import sys,gc
x=20
print x.__class__ # __class__ 通过类型指针来获取类型对象。

def test(x):
	print locals()# 可以看到 locals 名字空间中包含当前局部变量。
	print globals() is locals()#此时 locals 和 globals向不同名字空间。
	frame = sys._getframe(0)# _getframe(0) 获取当前堆栈帧。
	print locals() is frame.f_locals#locals 名字空间实际就是当前堆栈帧的名字空间。
	print globals() is frame.f_globals
test(123)

#内存管理
#为提升执⾏行性能，Python 在内存管理上做了大量工作。最直接的做法就是用内存池来减少操作系
#统内存分配和回收操作，那些小于等于 256 字节对象，将直接从内存池中获取存储空间。
#根据需要，虚拟机每次从操作系统申请⼀一块 256KB，取名为 arena 的大块内存。并按系统页大
#小，划分成多个 pool。每个 pool 继续分割成 n 个⼤大⼩小相同的 block，这是内存池最小存储单位。
#block ⼤大⼩小是 8 的倍数，也就是说存储 13 字节⼤大⼩小的对象，需要找 block 大小为 16 的 pool 获
#取空闲块。所有这些都⽤用头信息和链表管理起来，以便快速查找空闲区域进行分配。
#大于 256 字节的对象，直接⽤用 malloc 在堆上分配内存。程序运⾏行中的绝大多数对象都小于这个阀
#值，因此内存池策略可有效提升性能。
#当所有 arena 的总容量超出限制 (64MB) 时，就不再请求新的 arena 内存。而是如同 "大对象" 一
#样，直接在堆上为对象分配内存。另外，完全空闲的 arena 会被释放，其内存交还给操作系统。

print gc.get_threshold()# 获取各级代龄阀值
print gc.get_count()# 各级代龄链表跟踪的对象数量

#编译
#Python 实现了栈式虚拟机 (Stack-Based VM) 架构，通过与机器无关的字节码来实现跨平台执⾏行
#能力。这种字节码指令集没有寄存器，完全以栈 (抽象层面) 进行指令运算。尽管很简单，但对普通
#开发人员而言，是无需关心的细节。
#要运⾏行 Python 语言编写的程序，必须将源码编译成字节码。通常情况下，编译器会将源码转换成
#字节码后保存在 pyc 文件中。还可用 -O 参数⽣生成 pyo 格式，这是简单优化后的 pyc ⽂文件。
#编译发生在模块载入那一刻。具体来看，又分为 pyc 和 py 两种情况。
#载入 pyc 流程：
#• 核对文件 Magic 标记。
#• 检查时间戳和源码文件修改时间是否相同，以确定是否需要重新编译。
#• 载入模块。
#如果没有 pyc，那么就需要先完成编译：
#• 对源码进行 AST 分析。
#• 将分析结果编译成 PyCodeObject。
#• 将 Magic、源码⽂文件修改时间、PyCodeObject 保存到 pyc 文件中。
#• 载入模块。
#Magic 是一个特殊的数字，由 Python 版本号计算得来，作为 pyc文件和 Python 版本检查标记。
#PyCodeObject 则包含了代码对象的完整信息。

print sys.maxint
print type(sys.maxint)
print type(sys.maxint+1)

print sys._current_frames() #返回所有线程的当前堆栈帧对象。
#虚拟机会缓存 200 个堆栈帧复⽤用对象，以获得更好的执⾏行性能。
#整个程序跑下来，天知道要创建多少个这类对象

